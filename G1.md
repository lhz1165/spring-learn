# G1

1byte = 8bit

1kb = 2^10 byte

1mb = 2^10 kb

G1把堆分成4个区域,eden，survivor，old区（2的N次幂大小MB），超大对象Humongus。

G1回收只回收Collection Set里面的

## 如何解决跨代引用

Card Table:一个region（1MB=1024KB的）里面，每个card 512Byte，所有有2048张card。只要这里面存在跨代指针，那么就会图脏，标记为1.通过写屏障来维护这个CardTable

Rememberd Set: 别的region里面哪张card引用了我，然后把位置记录在当前region的rset里面。

通过rset就能知道哪些region引用了本region

## yong区的  gc

标记-复制, 把eden和survivor收集掉 然后拷贝到新的survivor.标记复制

## olde区的 gc(mix gc)

初始标记(STW) :标记gc root能直接关联的对象 

并发标记：使用可达性分析，找出回收的对象。并且使用[原始快照]{SATB}记录（漏标）

 最终标记(STW)  ：根据原始快照]{SATB}，解决漏标。

 筛选回收(STW) ：对region排序，把回收空间的活对象移动到空Region。

# CMS（old区的gc）

初始标记(STW) :标记gc root能直接关联的对象 

并发标记：使用可达性分析，找出回收的对象。

 重新标记(STW)  ：使用增量更新来修正（漏标）

 并发清理 ：标记清理算法

# 可达性分析问题解决

其一黑色的不会重新扫描，但是黑色的连上了白色的,其二删除了灰色到这个白色的连接。导致漏标

**增量更新：**黑色连接到白色时，记录这个插入，之后再把这个黑色再扫描一次

**原始快照：**灰色删除对白色的连接后，记录下这个删除，再把这个灰色的按照连接的时候扫描一次再扫描一次

# CMS和G1

处理漏标:cms增量更新，g1原始快照(通过写前屏障来记录状态)

维护卡表：都是通过写后屏障

算法：cms标记清理，g1标记整理，标记复制，因此cms碎片化空间，g1连续空间

cms和g1都无法处理浮动垃圾

