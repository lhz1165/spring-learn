# GFS（big  storage）

涉及：并行，性能，容错，复制，一致性

why hard？

为了性能，需要大量机器一起工作(这样可以并行处理)

为了并行，需要把数据分片存在不同机器（机器可能宕机，需要容错）

为了容错，需要有复制副本（副本和副本之间可能不同步）

为了同步，需要消除不一致性（但这会降低性能）

以上形成了循环，引出各种一致性来妥协

**GFS的好处**

大，快，全球的，分片的，自动恢复的，单数据中心，内部使用。

大的数据的顺序访问

通过【pretty 一致性】来保证好的性能

读：

1. 用知道的文件名和偏移量，发送给master
2. 通过master找到chunk hadle(chunk id),再利用chunk hadle去找到存放chunk的服务器列表。
3. 客户端和一个chunk服务器对话，告诉chunk的偏移量，找到对应的chunk返回给客户端

写：

通知master我要追加写到一个文件，询问这个文件的最后一个chunk的位置，然后在这后面append，

并且写一定要写入primary

没有Primary情况：master找出一组chunk server副本，mater通过本地持久化的最新版本号找出有最新chunk的副本。

选择其中一个为primary服务器，其他作为次要服务器。

master里的这个chunk的最新版本号写入磁盘。

master告诉所有chunk server 新的版本号，让他们更新，这样就找到了新的primary，给他一个租约

然后把数据写入临时位置，当确认主从都收到了之后，客户端告诉primary可以append了，primary选择偏移量让所有副本从这里开始写入，所有都给primary说写入成功，那么返回给客户端成功的响应，如果有的写入失败，那么会进行重试



append：





